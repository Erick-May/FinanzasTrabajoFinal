@page "/upload"
@rendermode InteractiveServer

@using System.IO
@using System.Data
@using ExcelDataReader
@using FinanzasTrabajoFinal.MODELS
@using FinanzasTrabajoFinal.Service
@using System.Globalization
@using Microsoft.EntityFrameworkCore

@* Usamos la inyección simple que SÍ te funcionaba *@
@inject IDbContextFactory<FinanzasContext> DbFactory
@inject UserStateService UserStateService
@inject NavigationManager NavigationManager
@inject ILogger<Upload> Logger

<div class="card shadow-lg" style="width: 32rem; border-radius: 1rem;">
    <div class="card-header bg-success text-white text-center p-4" style="border-top-left-radius: 1rem; border-top-right-radius: 1rem;">
        <h3 class="mb-0">
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" class="bi bi-file-earmark-arrow-up-fill me-2" viewBox="0 0 16 16">
                <path d="M9.293 0H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V4.707A1 1 0 0 0 13.707 4L10 0.293A1 1 0 0 0 9.293 0M9.5 3.5v-2l3 3h-2a1 1 0 0 1-1-1M6.354 9.854a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L6 8.293l1.146-1.147a.5.5 0 0 1 .708.708z" />
                <path d="M6 11.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 0 1h-1a.5.5 0 0 1-.5-.5" />
            </svg>
            Nuevo Análisis Financiero
        </h3>
    </div>
    <div class="card-body p-4">
        <p class="text-muted">
            Sube tu archivo de Excel (.xlsx) o CSV (.csv) con los Balances Generales y
            Estados de Resultados para comenzar el análisis.
        </p>
        <EditForm Model="formModel" OnValidSubmit="HandleAnalysis" FormName="UploadForm">
            <DataAnnotationsValidator />
            <div class="mb-3">
                <label for="fileUpload" class="form-label">Seleccionar archivo:</label>
                <InputFile id="fileUpload" class="form-control" OnChange="OnInputFileChange" accept=".xlsx, .csv" disabled="@isProcessing" />
            </div>
            @if (!string.IsNullOrEmpty(statusMessage))
            {
                <div class="alert alert-success" role="alert">
                    @statusMessage
                </div>
            }
            @if (!string.IsNullOrEmpty(errorMessage))
            {
                <div class="alert alert-danger" role="alert">
                    @errorMessage
                </div>
            }
            <div class="d-grid gap-2">
                <button type="submit" class="btn btn-success btn-lg" disabled="@(isProcessing || selectedFile == null)">
                    @if (isProcessing)
                    {
                        <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                        <span class="visually-hidden">Procesando...</span>
                    }
                    else
                    {
                        <span>Procesar Análisis</span>
                    }
                </button>
            </div>
        </EditForm>
        <hr class="my-4">
        <div class="d-flex justify-content-between align-items-center">
            <div></div>
            <div><a href="/">Volver al inicio</a></div>
        </div>
    </div>
</div>

@code {
    private IBrowserFile? selectedFile;
    private string statusMessage = "";
    private string errorMessage = "";
    private bool isProcessing = false;
    private UploadFormModel formModel = new UploadFormModel();
    private CultureInfo culture = new CultureInfo("es-ES");

    private void OnInputFileChange(InputFileChangeEventArgs e)
    {
        selectedFile = e.File;
        statusMessage = $"Archivo seleccionado: {selectedFile.Name}";
        errorMessage = "";
    }

    private async Task HandleAnalysis()
    {
        if (selectedFile == null || !UserStateService.IsLoggedIn)
        {
            errorMessage = "Por favor, selecciona un archivo y asegúrate de haber iniciado sesión.";
            return;
        }

        isProcessing = true;
        errorMessage = "";
        statusMessage = "Iniciando procesamiento...";
        StateHasChanged();

        AnalisisFinanciero? nuevoAnalisis = null;
        int idAnalisisGenerado = 0;

        try
        {
            await using var db = await DbFactory.CreateDbContextAsync();
            // 1. Crear Análisis
            nuevoAnalisis = new AnalisisFinanciero
            {
                IdUsuario = UserStateService.CurrentUser.IdUsuario,
                NombreArchivo = selectedFile.Name,
                FechaAnalisis = DateTime.Now
            };
            db.AnalisisFinancieros.Add(nuevoAnalisis);
            await db.SaveChangesAsync();
            idAnalisisGenerado = nuevoAnalisis.IdAnalisis;

            var conceptosBG = new List<BGConcepto>();
            var conceptosER = new List<ERConcepto>();

            // 2. Leer Excel
            await using var memoryStream = new MemoryStream();
            await selectedFile.OpenReadStream(maxAllowedSize: 10485760).CopyToAsync(memoryStream);
            memoryStream.Position = 0;

            using (var reader = ExcelReaderFactory.CreateReader(memoryStream))
            {
                var dataSet = reader.AsDataSet(new ExcelDataSetConfiguration()
                {
                    ConfigureDataTable = (_) => new ExcelDataTableConfiguration() { UseHeaderRow = false }
                });

                foreach (DataTable table in dataSet.Tables)
                {
                    var tipoHoja = DetectSheetType(table);
                    if (tipoHoja == SheetType.BalanceGeneral)
                    {
                        conceptosBG.AddRange(ParseBalanceGeneral(table, nuevoAnalisis.IdAnalisis));
                    }
                    else if (tipoHoja == SheetType.EstadoResultados)
                    {
                        conceptosER.AddRange(ParseEstadoResultados(table, nuevoAnalisis.IdAnalisis));
                    }
                }
            }

            if (conceptosBG.Count == 0 || conceptosER.Count == 0)
            {
                throw new Exception("No se pudieron leer datos. Revisa el formato del archivo.");
            }

            // 3. Guardar Datos Crudos
            await db.BGConceptos.AddRangeAsync(conceptosBG);
            await db.ERConceptos.AddRangeAsync(conceptosER);
            await db.SaveChangesAsync();

            // 4. CALCULAR RESULTADOS (Vertical, Horizontal y CNT)
            var resultadosVerticales = new List<ResultadoVertical>();
            var resultadosHorizontales = new List<ResultadoHorizontal>();

            // **** NUEVA LISTA PARA CNT ****
            var capitalesNetos = new List<CapitalesNetos>();

            var anios = conceptosBG.Select(c => c.Anio).Distinct().OrderBy(a => a).ToList();
            int anioAnterior = anios.First();
            int anioActual = anios.Last();

            // 4a. Vertical ER
            var ventasNetas = conceptosER
                .Where(c => c.Concepto.Trim().Equals("Ingresos", StringComparison.OrdinalIgnoreCase))
                .ToDictionary(c => c.Anio, c => c.Valor);

            foreach (var concepto in conceptosER)
            {
                decimal baseVentas = ventasNetas.GetValueOrDefault(concepto.Anio);
                if (baseVentas != 0)
                {
                    resultadosVerticales.Add(new ResultadoVertical
                    {
                        IdAnalisis = nuevoAnalisis.IdAnalisis,
                        TipoEstado = "ER",
                        Anio = concepto.Anio,
                        Concepto = concepto.Concepto,
                        Porcentaje = (concepto.Valor / baseVentas) * 100
                    });
                }
            }

            // 4b. Vertical BG
            var totalActivos = conceptosBG
                .Where(c => c.Concepto.Trim().Contains("Total Activos") || c.Concepto.Trim().Contains("Total de Activos"))
                .ToDictionary(c => c.Anio, c => c.Valor);
            var totalPasCap = conceptosBG
                .Where(c => c.Concepto.Trim().Contains("Total Pasivos y Capital"))
                .ToDictionary(c => c.Anio, c => c.Valor);

            foreach (var concepto in conceptosBG)
            {
                decimal baseValor = (concepto.Tipo == "ACTIVO") ? totalActivos.GetValueOrDefault(concepto.Anio) : totalPasCap.GetValueOrDefault(concepto.Anio);
                if (baseValor != 0)
                {
                    resultadosVerticales.Add(new ResultadoVertical
                    {
                        IdAnalisis = nuevoAnalisis.IdAnalisis,
                        TipoEstado = "BG",
                        Anio = concepto.Anio,
                        Concepto = concepto.Concepto,
                        Porcentaje = (concepto.Valor / baseValor) * 100
                    });
                }
            }

            // 4c. Horizontal BG
            var conceptosAgrupadosBG = conceptosBG.GroupBy(c => c.Concepto);
            foreach (var grupo in conceptosAgrupadosBG)
            {
                var valorAnterior = grupo.FirstOrDefault(c => c.Anio == anioAnterior)?.Valor ?? 0;
                var valorActual = grupo.FirstOrDefault(c => c.Anio == anioActual)?.Valor ?? 0;
                if (valorAnterior != 0)
                {
                    resultadosHorizontales.Add(new ResultadoHorizontal
                    {
                        IdAnalisis = nuevoAnalisis.IdAnalisis,
                        TipoEstado = "BG",
                        PeriodoInicial = anioAnterior,
                        PeriodoFinal = anioActual,
                        Concepto = grupo.Key,
                        VariacionAbsoluta = valorActual - valorAnterior,
                        VariacionRelativa = ((valorActual / valorAnterior) - 1) * 100
                    });
                }
            }

            // 4d. CALCULAR CNT Y GUARDAR EN LA NUEVA TABLA
            var actCirculante = conceptosBG
                .Where(c => c.Concepto.Trim().Equals("Total Activo Circulante", StringComparison.OrdinalIgnoreCase))
                .ToDictionary(c => c.Anio, c => c.Valor);
            var pasCirculante = conceptosBG
                .Where(c => c.Concepto.Trim().Equals("Total Pasivo Circulante", StringComparison.OrdinalIgnoreCase))
                .ToDictionary(c => c.Anio, c => c.Valor);

            foreach (var anio in anios)
            {
                decimal cnt = actCirculante.GetValueOrDefault(anio) - pasCirculante.GetValueOrDefault(anio);

                // Guardamos en la tabla Capitales_Netos
                capitalesNetos.Add(new CapitalesNetos
                {
                    IdAnalisis = nuevoAnalisis.IdAnalisis,
                    Anio = anio,
                    CNT = cnt,
                    CNO = null // Se queda vacío por ahora
                });
            }

            // --- 4e. CALCULAR ESTADO DE ORIGEN Y APLICACIÓN (EOAF) ---
            var origenAplicacionLista = new List<OrigenAplicacion>();

            // Recorremos los conceptos agrupados que ya teníamos
            foreach (var grupo in conceptosAgrupadosBG)
            {
                string concepto = grupo.Key;
                string tipo = grupo.First().Tipo; // "ACTIVO", "PASIVO", "CAPITAL"

                // OMITIR TOTALES (Tu Regla #2)
                if (concepto.StartsWith("Total", StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }

                var valorAnterior = grupo.FirstOrDefault(c => c.Anio == anioAnterior)?.Valor ?? 0;
                var valorActual = grupo.FirstOrDefault(c => c.Anio == anioActual)?.Valor ?? 0;
                decimal variacion = valorActual - valorAnterior;

                // Si no hay variación, no se añade
                if (variacion == 0)
                {
                    continue;
                }

                // TU REGLA #1 y #5: DEPRECIACIÓN
                if (concepto.Contains("Depreciacion Acumulada", StringComparison.OrdinalIgnoreCase))
                {
                    origenAplicacionLista.Add(new OrigenAplicacion
                    {
                        IdAnalisis = nuevoAnalisis.IdAnalisis,
                        PeriodoInicial = anioAnterior,
                        PeriodoFinal = anioActual,
                        Concepto = "Depreciación del Ejercicio", // Nombre limpio
                        Flujo = "ORIGEN", // Siempre Origen
                        Valor = Math.Abs(variacion) // Valor Positivo
                    });
                    continue; // Pasamos al siguiente concepto
                }

                // TU REGLA GENERAL DE CLASIFICACIÓN
                string flujo = "";
                if (tipo == "ACTIVO")
                {
                    flujo = (variacion > 0) ? "APLICACION" : "ORIGEN";
                }
                else if (tipo == "PASIVO" || tipo == "CAPITAL")
                {
                    flujo = (variacion > 0) ? "ORIGEN" : "APLICACION";
                }

                origenAplicacionLista.Add(new OrigenAplicacion
                {
                    IdAnalisis = nuevoAnalisis.IdAnalisis,
                    PeriodoInicial = anioAnterior,
                    PeriodoFinal = anioActual,
                    Concepto = concepto,
                    Flujo = flujo,
                    Valor = Math.Abs(variacion) // TU REGLA: Siempre valor absoluto
                });
            }

            //Cálculos (EOAF)
            await db.OrigenAplicaciones.AddRangeAsync(origenAplicacionLista);

            // --- 4f. CALCULAR RAZONES FINANCIERAS ---
            var listaRazones = new List<RazonFinanciera>();

            // Identificamos los años que tienen AMBOS (BG y ER)
            var aniosBG = conceptosBG.Select(c => c.Anio).Distinct();
            var aniosER = conceptosER.Select(c => c.Anio).Distinct();
            var aniosCompletos = aniosBG.Intersect(aniosER);

            foreach (var anio in aniosCompletos)
            {
                var bg = conceptosBG.Where(c => c.Anio == anio);
                var er = conceptosER.Where(c => c.Anio == anio);

                // --- 1. Razones de Liquidez ---
                decimal valorActCirculante = GetBGVal(bg, new[] { "Total Activo Circulante", "Total de Activo Circulante" });
                decimal valorPasCirculante = GetBGVal(bg, new[] { "Total Pasivo Circulante", "Total de Pasivo Circulante" });
                decimal inventarios = GetBGVal(bg, new[] { "Inventarios", "Inventario de Repuestos y Accesorios" });

                decimal razonCirculante = SafeDivide(valorActCirculante, valorPasCirculante);
                decimal razonRapida = SafeDivide(valorActCirculante - inventarios, valorPasCirculante);

                listaRazones.Add(new RazonFinanciera { IdAnalisis = nuevoAnalisis.IdAnalisis, Anio = anio, Grupo = "Liquidez", NombreRazon = "Razón Circulante", ValorRazon = razonCirculante });
                listaRazones.Add(new RazonFinanciera { IdAnalisis = nuevoAnalisis.IdAnalisis, Anio = anio, Grupo = "Liquidez", NombreRazon = "Razón Rápida", ValorRazon = razonRapida });

                // --- 2. Razones de Actividad ---
                decimal costoVentas = GetERVal(er, new[] { "Costos", "Costo de Bienes Vendidos", "Costos de ventas de bienes y servicios" });
                decimal cuentasCobrar = GetBGVal(bg, new[] { "Cuentas y Documentos Por Cobrar", "Cuentas por Cobrar" });
                decimal ventas = GetERVal(er, new[] { "Ingresos", "Ventas", "Ventas Netas", "Ingresos Operacionales" });
                decimal activosFijosNetos = GetBGVal(bg, new[] { "Activos fijos netos", "Total Activos Fijos", "Total de Activos Fijos", "Total Activo Fijo" });
                decimal activosTotales = GetBGVal(bg, new[] { "Total Activos", "Total de Activos" });

                decimal rotInventarios = SafeDivide(costoVentas, inventarios);
                decimal rotCuentasCobrar = SafeDivide(ventas, cuentasCobrar);
                decimal periodoCobro = SafeDivide(360, rotCuentasCobrar);
                decimal rotActivosFijos = SafeDivide(ventas, activosFijosNetos);
                decimal rotActivosTotales = SafeDivide(ventas, activosTotales);

                listaRazones.Add(new RazonFinanciera { IdAnalisis = nuevoAnalisis.IdAnalisis, Anio = anio, Grupo = "Actividad", NombreRazon = "Rotación de Inventarios", ValorRazon = rotInventarios });
                listaRazones.Add(new RazonFinanciera { IdAnalisis = nuevoAnalisis.IdAnalisis, Anio = anio, Grupo = "Actividad", NombreRazon = "Rotación de Cuentas por Cobrar", ValorRazon = rotCuentasCobrar });
                listaRazones.Add(new RazonFinanciera { IdAnalisis = nuevoAnalisis.IdAnalisis, Anio = anio, Grupo = "Actividad", NombreRazon = "Periodo Promedio de Cobro", ValorRazon = periodoCobro });
                listaRazones.Add(new RazonFinanciera { IdAnalisis = nuevoAnalisis.IdAnalisis, Anio = anio, Grupo = "Actividad", NombreRazon = "Rotación de Activos Fijos", ValorRazon = rotActivosFijos });
                listaRazones.Add(new RazonFinanciera { IdAnalisis = nuevoAnalisis.IdAnalisis, Anio = anio, Grupo = "Actividad", NombreRazon = "Rotación de Activos Totales", ValorRazon = rotActivosTotales });

                // --- Datos para Endeudamiento y Rentabilidad ---
                decimal utilidadBruta = GetERVal(er, new[] { "Utilidad Bruta" });
                decimal gastosOperativos = GetERVal(er, new[] { "Gastos", "Gastos de ventas y administrativos", "Gastos Operativos" });
                decimal utilidadOperativa = utilidadBruta - gastosOperativos; // Calculada
                decimal gastoIntereses = GetERVal(er, new[] { "Gasto por Intereses", "Gastos Financieros", "Intereses Pagados" });

                // --- 3. Razones de Endeudamiento ---
                decimal capitalNeto = GetBGVal(bg, new[] { "Total Capital", "Patrimonio Neto", "Capital Contable", "Total Patrimonio", "Total Capital Contable" });

                // ++++++ ¡AQUÍ ESTÁ EL ARREGLO! LÓGICA SIMPLE ++++++
                // 1. Buscamos los valores que SÍ existen
                decimal totalPasivos = GetBGVal(bg, new[] { "Total Pasivos", "Total de Pasivos" });
                decimal pasivoNoCirculante = GetBGVal(bg, new[] { "Total Pasivo No Circulante", "Total de Pasivo No Circulante", "Pasivos No Circulantes" });

                // 2. Si falta "Total Pasivos", lo calculamos
                if (totalPasivos == 0 && (valorPasCirculante != 0 || pasivoNoCirculante != 0))
                {
                    totalPasivos = valorPasCirculante + pasivoNoCirculante;
                }

                // 3. Si falta "Pasivo No Circulante", lo calculamos
                if (pasivoNoCirculante == 0 && totalPasivos != 0)
                {
                    pasivoNoCirculante = totalPasivos - valorPasCirculante;
                }
                // ++++++ FIN DEL ARREGLO ++++++

                // 4. Ahora calculamos las razones
                decimal razonEndeudamiento = SafeDivide(totalPasivos, activosTotales);
                // 5. Aplicamos tu regla de Absoluto ANTES de dividir
                decimal razonPasivoCapital = SafeDivide(Math.Abs(pasivoNoCirculante), capitalNeto); // ¡Tu fórmula corregida!
                decimal rotacionIntereses = SafeDivide(utilidadOperativa, gastoIntereses);

                listaRazones.Add(new RazonFinanciera { IdAnalisis = nuevoAnalisis.IdAnalisis, Anio = anio, Grupo = "Endeudamiento", NombreRazon = "Razón de Endeudamiento", ValorRazon = razonEndeudamiento });
                listaRazones.Add(new RazonFinanciera { IdAnalisis = nuevoAnalisis.IdAnalisis, Anio = anio, Grupo = "Endeudamiento", NombreRazon = "Razón Pasivo / Capital", ValorRazon = razonPasivoCapital });
                listaRazones.Add(new RazonFinanciera { IdAnalisis = nuevoAnalisis.IdAnalisis, Anio = anio, Grupo = "Endeudamiento", NombreRazon = "Rotación de Intereses a Utilidades", ValorRazon = rotacionIntereses });

                // --- 4. Razones de Rentabilidad (¡en %!) ---
                decimal utilidadNeta = GetERVal(er, new[] { "Utilidad neta", "Utilidad o Perdida del Ejercicio", "Resultado del Ejercicio", "Beneficio Neto" });

                decimal mub = SafeDivide(utilidadBruta, ventas) * 100;
                decimal muo = SafeDivide(utilidadOperativa, ventas) * 100;
                decimal margenNeto = SafeDivide(utilidadNeta, ventas) * 100;
                decimal roa = SafeDivide(utilidadNeta, activosTotales) * 100;

                listaRazones.Add(new RazonFinanciera { IdAnalisis = nuevoAnalisis.IdAnalisis, Anio = anio, Grupo = "Rentabilidad", NombreRazon = "Margen de Utilidad Bruta (MUB)", ValorRazon = mub });
                listaRazones.Add(new RazonFinanciera { IdAnalisis = nuevoAnalisis.IdAnalisis, Anio = anio, Grupo = "Rentabilidad", NombreRazon = "Margen de Utilidad Operativa (MUO)", ValorRazon = muo });
                listaRazones.Add(new RazonFinanciera { IdAnalisis = nuevoAnalisis.IdAnalisis, Anio = anio, Grupo = "Rentabilidad", NombreRazon = "Margen de Utilidad Neta", ValorRazon = margenNeto });
                listaRazones.Add(new RazonFinanciera { IdAnalisis = nuevoAnalisis.IdAnalisis, Anio = anio, Grupo = "Rentabilidad", NombreRazon = "Rentabilidad sobre el Activo (ROA)", ValorRazon = roa });
            }

            //Cálculos (Razones)
            await db.RazonesFinancieras.AddRangeAsync(listaRazones);
            // 5. Guardar Cálculos
            await db.ResultadoVerticales.AddRangeAsync(resultadosVerticales);
            await db.ResultadoHorizontales.AddRangeAsync(resultadosHorizontales);
            await db.CapitalesNetos.AddRangeAsync(capitalesNetos);

            await db.SaveChangesAsync();

            // 6. Redirigir
            statusMessage = "¡Análisis completado!";

        }
        catch (Exception ex)
        {
            statusMessage = "";
            errorMessage = $"Error: {ex.Message} | {ex.InnerException?.Message}";
            Logger.LogError(ex, "Error en HandleAnalysis");

            // Verificamos si el análisis se alcanzó a crear en la BD
            // (Tu variable 'idAnalisisGenerado' nos sirve para esto)
            if (idAnalisisGenerado > 0 && nuevoAnalisis != null)
            {
                try
                {
                    // ¡ARREGLO! Creamos un nuevo contexto SOLO para borrar
                    await using var rollbackDb = await DbFactory.CreateDbContextAsync();

                    // Usamos el nuevo 'rollbackDb'
                    rollbackDb.AnalisisFinancieros.Remove(nuevoAnalisis);
                    await rollbackDb.SaveChangesAsync();
                }
                catch (Exception rollbackEx)
                {
                    // Si hasta el borrado falla, solo lo registramos
                    Logger.LogError(rollbackEx, "Error al intentar hacer rollback del análisis");
                }
            }
        }
        finally
        {
            isProcessing = false;
            StateHasChanged();
        }

        if (idAnalisisGenerado > 0 && string.IsNullOrEmpty(errorMessage))
        {
            NavigationManager.NavigateTo($"/resultados/{idAnalisisGenerado}");
        }
    }

    // --- TUS MÉTODOS DE PARSEO ORIGINALES ---
    private enum SheetType { Unknown, BalanceGeneral, EstadoResultados }

    private SheetType DetectSheetType(DataTable table)
    {
        foreach (DataRow row in table.Rows)
        {
            string concepto = SafeGetString(row, 0);
            if (concepto.Equals("Total de Activos", StringComparison.OrdinalIgnoreCase)) return SheetType.BalanceGeneral;
            if (concepto.Equals("Total Pasivos y Capital", StringComparison.OrdinalIgnoreCase)) return SheetType.BalanceGeneral;
            if (concepto.Equals("Utilidad neta", StringComparison.OrdinalIgnoreCase)) return SheetType.EstadoResultados;
        }
        return SheetType.Unknown;
    }

    private int SafeGetYear(DataRow row, int colIndex)
    {
        if (colIndex < 0 || colIndex >= row.Table.Columns.Count || row.IsNull(colIndex)) return 0;
        var cellValue = row[colIndex];
        if (cellValue is double dValue) return (int)dValue;
        string sVal = cellValue.ToString().Trim();
        if (int.TryParse(sVal, out int iVal)) return iVal;
        if (double.TryParse(sVal, NumberStyles.Any, CultureInfo.InvariantCulture, out double dVal)) return (int)dVal;
        return 0;
    }

    private List<ERConcepto> ParseEstadoResultados(DataTable table, int analisisId)
    {
        var conceptos = new List<ERConcepto>();
        int headerRowIndex = -1, year1 = 0, year2 = 0, colAnio1 = -1, colAnio2 = -1, descripColIndex = -1;

        for (int i = 0; i < 10 && i < table.Rows.Count; i++)
        {
            for (int j = 0; j < table.Columns.Count; j++)
            {
                if (SafeGetString(table.Rows[i], j).StartsWith("Descrip", StringComparison.OrdinalIgnoreCase))
                {
                    headerRowIndex = i; descripColIndex = j;
                    colAnio1 = descripColIndex + 2; colAnio2 = descripColIndex + 3;
                    year1 = SafeGetYear(table.Rows[i], colAnio1); year2 = SafeGetYear(table.Rows[i], colAnio2);
                    if (year1 > 2000 && year2 > 2000) { break; } else { headerRowIndex = -1; }
                }
            }
            if (headerRowIndex != -1) break;
        }

        if (headerRowIndex == -1) throw new Exception("No se encontró el encabezado en ER.");

        for (int i = headerRowIndex + 1; i < table.Rows.Count; i++)
        {
            DataRow row = table.Rows[i];
            string concepto = SafeGetString(row, descripColIndex);
            if (string.IsNullOrWhiteSpace(concepto)) continue;
            conceptos.Add(new ERConcepto { IdAnalisis = analisisId, Anio = year1, Concepto = concepto, Valor = SafeGetDecimal(row, colAnio1, culture) });
            conceptos.Add(new ERConcepto { IdAnalisis = analisisId, Anio = year2, Concepto = concepto, Valor = SafeGetDecimal(row, colAnio2, culture) });
            if (concepto.Equals("Utilidad neta", StringComparison.OrdinalIgnoreCase)) break;
        }
        return conceptos;
    }

    private List<BGConcepto> ParseBalanceGeneral(DataTable table, int analisisId)
    {
        var conceptos = new List<BGConcepto>();
        int headerRowIndex = -1, year1 = 0, year2 = 0, colAnio1 = -1, colAnio2 = -1, descripColIndex = -1;
        string currentType = "ACTIVO";

        for (int i = 0; i < 10 && i < table.Rows.Count; i++)
        {
            for (int j = 0; j < table.Columns.Count; j++)
            {
                if (SafeGetString(table.Rows[i], j).StartsWith("Descrip", StringComparison.OrdinalIgnoreCase))
                {
                    headerRowIndex = i; descripColIndex = j;
                    colAnio1 = descripColIndex + 2;
                    colAnio2 = descripColIndex + 3; // Tu Excel tiene los años en C y D
                    year1 = SafeGetYear(table.Rows[i], colAnio1); year2 = SafeGetYear(table.Rows[i], colAnio2);
                    if (year1 > 2000 && year2 > 2000) { break; } else { headerRowIndex = -1; }
                }
            }
            if (headerRowIndex != -1) break;
        }

        if (headerRowIndex == -1) throw new Exception("No se encontró el encabezado en BG.");

        for (int i = headerRowIndex + 1; i < table.Rows.Count; i++)
        {
            DataRow row = table.Rows[i];
            string concepto = SafeGetString(row, descripColIndex);
            if (concepto.Equals("Pasivos", StringComparison.OrdinalIgnoreCase)) { currentType = "PASIVO"; continue; }
            if (concepto.Equals("Capital", StringComparison.OrdinalIgnoreCase)) { currentType = "CAPITAL"; continue; }

            // ++++++ FILTRO CORREGIDO (EL BUENO) ++++++
            // Solo omitimos los encabezados que NO tienen valores
            if (string.IsNullOrWhiteSpace(concepto) ||
                concepto.Equals("Activos", StringComparison.OrdinalIgnoreCase) ||
                concepto.Equals("Activos Circulantes", StringComparison.OrdinalIgnoreCase) ||
                concepto.Equals("Activos Fijos", StringComparison.OrdinalIgnoreCase) ||
                concepto.Equals("Activos No Circulantes", StringComparison.OrdinalIgnoreCase) ||
                concepto.Equals("Pasivos Circulantes", StringComparison.OrdinalIgnoreCase)
                // ¡¡¡AQUÍ ESTÁ EL ARREGLO!! Quité la línea que bloqueaba "Pasivos No Circulantes"
                )
            {
                continue; // Solo omite los ENCABEZADOS simples, pero no los "Totales"
            }
            // ++++++ FIN DEL ARREGLO ++++++

            // ARREGLO 2: Invertimos el orden. Primero guardamos, LUEGO hacemos break.
            conceptos.Add(new BGConcepto { IdAnalisis = analisisId, Anio = year1, Concepto = concepto, Tipo = currentType, Valor = SafeGetDecimal(row, colAnio1, culture) });
            conceptos.Add(new BGConcepto { IdAnalisis = analisisId, Anio = year2, Concepto = concepto, Tipo = currentType, Valor = SafeGetDecimal(row, colAnio2, culture) });

            if (concepto.Equals("Total Pasivos y Capital", StringComparison.OrdinalIgnoreCase))
            {
                break; // Ahora el 'break' está DESPUÉS de guardar.
            }
        }
        return conceptos;
    }

    private string SafeGetString(DataRow row, int colIndex)
    {
        if (colIndex < 0 || colIndex >= row.Table.Columns.Count || row.IsNull(colIndex)) return string.Empty;
        return row[colIndex].ToString().Trim();
    }

    private decimal SafeGetDecimal(DataRow row, int colIndex, CultureInfo culture)
    {
        if (colIndex < 0 || colIndex >= row.Table.Columns.Count || row.IsNull(colIndex)) return 0m;
        var cellValue = row[colIndex];
        if (cellValue is double dValue) return (decimal)dValue;
        string sVal = cellValue.ToString().Trim().Replace("C$", "").Replace("(", "-").Replace(")", "");
        if (decimal.TryParse(sVal, NumberStyles.Any, culture, out decimal res)) return res;
        if (decimal.TryParse(sVal, NumberStyles.Any, CultureInfo.InvariantCulture, out res)) return res;
        return 0m;
    }

    public class UploadFormModel { }

    /// <summary>
    /// Busca un valor en la lista del Balance General por varios nombres posibles.
    /// </summary>
    private decimal GetBGVal(IEnumerable<BGConcepto> bgAnio, string[] conceptNames)
    {
        foreach (var name in conceptNames)
        {
            var concepto = bgAnio.FirstOrDefault(c => c.Concepto.Trim().Equals(name, StringComparison.OrdinalIgnoreCase));
            if (concepto != null)
            {
                return concepto.Valor;
            }
        }
        return 0m; // Devuelve 0 si no se encuentra
    }

    /// <summary>
    /// Busca un valor en la lista del Estado de Resultados por varios nombres posibles.
    /// </summary>
    private decimal GetERVal(IEnumerable<ERConcepto> erAnio, string[] conceptNames)
    {
        foreach (var name in conceptNames)
        {
            var concepto = erAnio.FirstOrDefault(c => c.Concepto.Trim().Equals(name, StringComparison.OrdinalIgnoreCase));
            if (concepto != null)
            {
                return concepto.Valor;
            }
        }
        return 0m;
    }

    /// <summary>
    /// Divide dos números de forma segura, evitando errores de división por cero.
    /// </summary>
    private decimal SafeDivide(decimal numerator, decimal denominator)
    {
        return (denominator == 0) ? 0 : (numerator / denominator);
    }
}